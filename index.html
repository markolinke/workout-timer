<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Rep Interval Timer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- png favicon -->
  <link rel="icon" type="image/png" href="favicon.png">
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: #222;
      color: #fff;
      margin: 0;
      padding: 20px;
    }

    h1 {
      margin: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .workout-title {
      display: inline;
    }

    .workout-menu-trigger {
      color: #888;
      cursor: pointer;
      font-size: 0.6em;
      text-decoration: none;
      padding: 5px 10px;
      border-radius: 5px;
      transition: all 0.2s;
    }

    .workout-menu-trigger:hover {
      color: #4CAF50;
      background: rgba(255, 255, 255, 0.1);
    }

    .container {
      max-width: 558px;
      margin: 0 auto;
      padding: 20px;
      background: #333;
      border-radius: 15px;
    }

    .settings {
      margin: 20px 0;
    }

    label {
      display: inline-block;
      width: 180px;
      text-align: right;
      margin: 8px;
    }

    input {
      width: 70px;
      padding: 8px;
      font-size: 1.2em;
      text-align: center;
    }

    button {
      padding: 0;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      margin: 12px 20px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.1s, background-color 0.2s;
    }

    button:active {
      transform: scale(0.95);
    }

    button svg {
      width: 40px;
      height: 40px;
      fill: white;
    }

    #mainBtn {
      background: #4CAF50;
      color: white;
      font-weight: bold;
      margin: 12px 8px;
      /* Closer to neighbors */
      width: 90px;
      /* Slightly larger for emphasis */
      height: 90px;
    }

    #prevBtn,
    #nextBtn {
      background: #333;
      /* Dark background */
      margin: 12px 8px;
      /* Closer to main button */
      width: 60px;
      /* Smaller than main */
      height: 60px;
    }

    #prevBtn:hover,
    #nextBtn:hover {
      background: #444;
    }

    #resetBtn {
      background: #555;
      color: white;
      margin-left: 40px;
      /* Push away from the group */
    }

    .timer-display {
      font-size: 5.5em;
      margin: 30px 0;
      font-weight: bold;
    }

    .progress {
      font-size: 1.3em;
      color: #aaa;
    }

    .beep {
      display: none;
    }

    .hidden {
      display: none !important;
    }

    /* GRID SCOREBOARD STYLES */
    .scoreboard-container {
      display: block;
      width: fit-content;
      max-width: 100%;
      box-sizing: border-box;
      margin: 25px auto;
      border-radius: 12px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6), inset 0 1px 1px rgba(255, 255, 255, 0.1);
      background: linear-gradient(145deg, #0a1f44, #051025);
      padding: 15px;
      border: 1px solid #1e3a6e;
      overflow-x: auto;
      /* Allow horizontal scroll on desktop */
    }

    .sb-grid {
      display: grid;
      gap: 6px;
      /* Desktop Default: Horizontal Flow */
      grid-template-rows: auto auto;
      /* Planned, Completed */
      grid-auto-flow: column;
      align-items: center;
    }

    /* Common Cell Styles */
    .sb-cell {
      padding: 10px 5px;
      text-align: center;
      min-width: 45px;
      border-radius: 8px;
      position: relative;
      transition: all 0.3s ease;
      font-family: 'Verdana', sans-serif;
    }

    /* Headers */
    .sb-header {
      color: #88aadd;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 0.8em;
      background: transparent;
      border: none;
    }

    .sb-header-round,
    .sb-round-label {
      display: none;
      /* Hidden on desktop */
    }

    .sb-header-planned,
    .sb-header-completed {
      text-align: right;
      padding-right: 15px;
      width: 100px;
    }

    /* Values */
    .sb-val-planned {
      background-color: rgba(255, 255, 255, 0.05);
      color: #aaa;
      font-size: 0.9em;
    }

    .sb-val-completed {
      background-color: rgba(255, 255, 255, 0.1);
      font-weight: bold;
      font-size: 1.2em;
      color: #fff;
    }

    /* Active/Past/Future Styles */
    .col-active {
      background-color: #ccff00 !important;
      color: #000 !important;
      box-shadow: 0 0 15px rgba(204, 255, 0, 0.6);
      transform: scale(1.1);
      z-index: 10;
      border: 2px solid #fff;
      animation: pulse-glow 2s infinite;
    }

    .col-past {
      background-color: #004d25 !important;
      color: #fff !important;
      border: 1px solid #006633;
    }

    .col-future {
      opacity: 0.5;
    }

    @keyframes pulse-glow {
      0% {
        box-shadow: 0 0 10px rgba(204, 255, 0, 0.4);
      }

      50% {
        box-shadow: 0 0 20px rgba(204, 255, 0, 0.8);
      }

      100% {
        box-shadow: 0 0 10px rgba(204, 255, 0, 0.4);
      }
    }

    /* MOBILE: Vertical Flow */
    @media (max-width: 600px) {
      .scoreboard-container {
        width: 100%;
        overflow-x: visible;
        /* No scroll needed usually, or vertical scroll handled by page */
        padding: 10px;
        /* Reduce container padding */
      }

      .sb-grid {
        grid-template-rows: auto;
        /* Reset rows */
        grid-template-columns: 0.4fr 1fr 1fr;
        /* Reduce Round column width */
        grid-auto-flow: row;
        gap: 4px;
        /* Reduce gap */
      }

      .sb-header-round,
      .sb-round-label {
        display: block;
        /* Show on mobile */
        text-align: center;
        /* Center align round number */
        padding-left: 0;
        color: #88aadd;
        font-weight: bold;
      }

      .sb-round-label {
        font-size: 0.9em;
        color: #aaa;
      }

      .sb-header-planned,
      .sb-header-completed {
        text-align: center;
        width: auto;
        padding: 0;
      }

      /* Adjust cell styles for mobile */
      .sb-cell {
        min-width: auto;
        padding: 6px 2px;
        /* Reduce cell padding */
        font-size: 0.9em;
        max-width: 100px;
        /* Slightly smaller font */
      }

      /* Toggle Text Visibility */
      .desktop-text {
        display: none;
      }

      .mobile-text {
        display: inline;
      }

      /* Responsive Buttons */
      #mainBtn {
        width: 70px;
        height: 70px;
        margin: 8px 4px;
      }

      #prevBtn,
      #nextBtn {
        width: 50px;
        height: 50px;
        margin: 8px 4px;
      }

      #resetBtn {
        width: 50px;
        height: 50px;
        margin-left: 15px;
        margin-right: 4px;
      }

      button svg {
        width: 24px;
        height: 24px;
      }

      #mainBtn svg {
        width: 32px;
        height: 32px;
      }
    }

    /* Desktop Defaults for Text Toggles */
    .mobile-text {
      display: none;
    }

    .desktop-text {
      display: inline;
    }

    /* MODAL STYLES */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      align-items: center;
      justify-content: center;
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
      padding: 30px;
      border-radius: 15px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
      border: 1px solid #444;
    }

    .modal-header {
      font-size: 1.5em;
      margin-bottom: 20px;
      color: #4CAF50;
      text-align: center;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .mute-btn {
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 5px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      transition: background 0.2s;
      position: relative;
    }

    .mute-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .sound-icon-container {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .mute-btn svg {
      width: 24px;
      height: 24px;
      fill: #aaa;
      transition: fill 0.2s;
    }

    .mute-btn:hover svg {
      fill: #fff;
    }

    .volume-bars {
      position: absolute;
      right: -18px;
      display: flex;
      align-items: flex-end;
      gap: 2px;
      height: 16px;
    }

    .volume-bar {
      width: 3px;
      background: #4CAF50;
      border-radius: 1px;
      transition: height 0.2s, opacity 0.2s;
      opacity: 0;
      height: 0;
    }

    .volume-bar.active {
      opacity: 1;
    }

    .volume-bar.bar-1 {
      height: 4px;
    }

    .volume-bar.bar-2 {
      height: 7px;
    }

    .volume-bar.bar-3 {
      height: 11px;
    }

    .volume-bar.bar-4 {
      height: 16px;
    }

    .workout-option {
      display: block;
      width: 100%;
      padding: 15px;
      margin: 10px 0;
      background: #333;
      border: 1px solid #555;
      border-radius: 10px;
      color: #fff;
      font-size: 1.1em;
      cursor: pointer;
      transition: all 0.3s;
    }

    .workout-option:hover {
      background: #4CAF50;
      border-color: #4CAF50;
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
    }

    .modal-close {
      margin-top: 20px;
      padding: 10px;
      background: #555;
      border: none;
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      width: 100%;
      font-size: 1em;
    }

    .modal-close:hover {
      background: #666;
    }

    @media (max-width: 600px) {
      body {
        padding-left: 10px;
        padding-right: 10px;
      }

      .settings>div {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .settings label {
        width: 100%;
        text-align: center;
        margin-bottom: 5px;
      }
    }

    .timer-display {
      font-size: 5.5em;
      /* Increased from 5.5em for better visibility if needed, but keeping same for now */
      margin: 0;
      /* Removing margin to handle via flex gap */
      font-weight: bold;
      line-height: 1;
    }

    .timer-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      margin: 30px 0;
    }

    .calf-visual-container {
      width: 40px;
      height: 120px;
      /* Match approximate height of timer text */
      background: #111;
      border: 2px solid #555;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      /* Hidden by default, JS Toggles it */
      display: none;
    }

    .calf-visual-fill {
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, #4CAF50, #2e7d32);
      transform: scaleY(1);
      transform-origin: top;
      transition: transform 0.08s linear;
    }
  </style>
</head>

<body>

  <div class="container">



    <h1>
      <span class="workout-title" id="workoutTitle">Rep Interval Timer</span>
      <a class="workout-menu-trigger" id="workoutMenuTrigger">...</a>
    </h1>

    <!-- SETUP CONTAINER -->
    <div id="setup-container">
      <div class="settings">
        <div><label>Rounds:</label> <input type="number" id="rounds" min="1"></div>
        <div><label>Reps per round:</label> <input type="number" id="reps" min="1"></div>
        <div><label>Work per rep (sec):</label> <input type="number" id="work" min="1"></div>
        <div><label>Rest between reps (sec):</label> <input type="number" id="rest" min="0"></div>
        <div><label>Rest between rounds (sec):</label> <input type="number" id="roundRest" min="0"></div>
      </div>

      <div style="margin: 20px 0; font-size: 1.4em; color: #aaa;">
        Total workout: <strong id="totalTimeDisplay">—</strong>
      </div>
    </div>

    <div style="display: flex; justify-content: center; align-items: center;">
      <button id="prevBtn" class="hidden">
        <!-- Prev Icon -->
        <svg viewBox="0 0 24 24">
          <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z" />
        </svg>
      </button>

      <button id="mainBtn">
        <!-- Play Icon -->
        <svg id="icon-play" viewBox="0 0 24 24">
          <path d="M8 5v14l11-7z" />
        </svg>
        <!-- Pause Icon -->
        <svg id="icon-pause" class="hidden" viewBox="0 0 24 24">
          <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
        </svg>
      </button>

      <button id="nextBtn" class="hidden">
        <!-- Next Icon -->
        <svg viewBox="0 0 24 24">
          <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z" />
        </svg>
      </button>

      <button id="resetBtn" class="hidden">
        <!-- Stop Icon (Square) -->
        <svg viewBox="0 0 24 24">
          <path d="M6 6h12v12H6z" />
        </svg>
      </button>
    </div>

    <!-- RUNNING CONTAINER -->
    <div id="running-container" class="hidden">
      <div class="timer-container">
        <div class="timer-display" id="timer">00:00</div>
        <!-- Moved Calf Bar -->
        <div id="calfBarContainer" class="calf-visual-container">
          <div id="calfBar" class="calf-visual-fill"></div>
        </div>
      </div>
      <!-- GRID SCOREBOARD -->
      <div class="scoreboard-container">
        <div style="width: 100%; padding-bottom: 5px;">
          <div class="sb-grid" id="sbGrid">
            <!-- Generated by JS -->
          </div>
        </div>

        <!-- TOTAL PROGRESS BAR -->
        <div id="totalBarContainer" style="margin-top: 15px; width: 100%;">
          <div
            style="width: 100%; height: 18px; background: #111; border-radius: 9px; overflow: hidden; border: 2px solid #555;">
            <div id="totalBar"
              style="width: 100%; height: 100%; background: linear-gradient(to right, #4CAF50, #2e7d32); transform: scaleX(0); transform-origin: left; transition: transform 0.08s linear;">
            </div>
          </div>
        </div>
      </div>

      <div class="progress" id="progress"></div>
    </div>
  </div>



  <!-- WORKOUT SELECTION MODAL -->
  <div id="workoutModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        Select Workout
        <button id="muteBtn" class="mute-btn" title="Toggle Sound">
          <div class="sound-icon-container">
            <!-- Speaker Icon -->
            <svg id="icon-sound-on" viewBox="0 0 24 24">
              <path
                d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z" />
            </svg>
            <!-- Mute Icon -->
            <svg id="icon-sound-off" class="hidden" viewBox="0 0 24 24">
              <path
                d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z" />
            </svg>
            <!-- Volume Bars Indicator -->
            <div class="volume-bars">
              <div class="volume-bar" id="volume-bar-1"></div>
              <div class="volume-bar" id="volume-bar-2"></div>
              <div class="volume-bar" id="volume-bar-3"></div>
              <div class="volume-bar" id="volume-bar-4"></div>
            </div>
          </div>
        </button>
      </div>
      <div id="workoutList">
        <!-- Generated by JS -->
      </div>
      <div style="display: flex; justify-content: center;">
        <button class="modal-close" id="modalClose">Close</button>
      </div>
    </div>
  </div>

  <script src="script.js"></script>
  <script>
    // Functions are now global from script.js
    // Predefined workouts
    const PREDEFINED_WORKOUTS = [
      {
        id: 'alfredson',
        name: 'Alfredson',
        config: {
          rounds: 6,
          reps: 15,
          work: 5,
          rest: 1,
          roundRest: 20
        }
      },
      {
        id: 'calf-2x15',
        name: 'Calf Raise',
        config: {
          rounds: 2,
          reps: 12,
          work: 3,
          rest: 3,
          roundRest: 15
        }
      },
      {
        id: 'test-1r-1rep',
        name: 'Test: 1R x 1Rep',
        config: {
          rounds: 1,
          reps: 1,
          work: 1,
          rest: 1,
          roundRest: 1
        }
      },
      {
        id: 'test-2r-1rep',
        name: 'Test: 2R x 1Rep',
        config: {
          rounds: 2,
          reps: 1,
          work: 1,
          rest: 1,
          roundRest: 2
        }
      },
      {
        id: 'test-1r-2reps',
        name: 'Test: 1R x 2Reps',
        config: {
          rounds: 1,
          reps: 2,
          work: 1,
          rest: 1,
          roundRest: 1
        }
      },
      {
        id: 'test-2r-2reps',
        name: 'Test: 2R x 2Reps',
        config: {
          rounds: 2,
          reps: 2,
          work: 1,
          rest: 1,
          roundRest: 2
        }
      }
    ];

    // Default configuration values (Alfredson Protocol)
    const DEFAULT_CONFIG = PREDEFINED_WORKOUTS[0].config;
    let currentWorkout = PREDEFINED_WORKOUTS[0];


    const timerDisplay = document.getElementById('timer');
    const progressDisplay = document.getElementById('progress');
    const mainBtn = document.getElementById('mainBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');

    const setupContainer = document.getElementById('setup-container');
    const runningContainer = document.getElementById('running-container');
    const tickTime = 100;

    let countdown;
    let totalSeconds = 0;
    let totalWorkoutSeconds = 0;
    let currentRound = 1;
    let currentRep = 1;
    let isWorking = true;
    let isRoundRest = false;
    let isRunning = false;
    let isPaused = false;
    let workoutStartedAt = null;        // timestamp when START was pressed
    let pausedTimeTotal = 0;           // total seconds spent paused
    let lastPauseStart = null;        // when current pause began
    let getReadyActive = false;
    let lastDingSecond = null;        // track which second we last played a ding (to avoid multiple plays per second)
    let lastRoundRestDingSecond = null; // track which second we last played a round rest ding

    // Simple calf drop visual bar
    const calfBar = document.getElementById('calfBar');
    const calfBarContainer = document.getElementById('calfBarContainer');

    function toggleView(showRunning) {
      const resetBtn = document.getElementById('resetBtn');
      if (showRunning) {
        setupContainer.classList.add('hidden');
        runningContainer.classList.remove('hidden');
        resetBtn.classList.remove('hidden');
        prevBtn.classList.remove('hidden');
        nextBtn.classList.remove('hidden');
      } else {
        setupContainer.classList.remove('hidden');
        runningContainer.classList.add('hidden');
        resetBtn.classList.add('hidden');
        prevBtn.classList.add('hidden');
        nextBtn.classList.add('hidden');
      }
    }

    function updateVisualBars() {
      if (getReadyActive || !isRunning) {
        calfBarContainer.style.display = 'none';
        return;
      }
      calfBarContainer.style.display = 'block';

      if (isWorking) {
        // WORK = lowering = fill from TOP to BOTTOM
        const progress = (parseInt(document.getElementById('work').value) - totalSeconds) / parseInt(document.getElementById('work').value);
        calfBar.style.transform = `scaleY(${progress})`;
        calfBar.style.transformOrigin = 'top';
        calfBar.style.background = 'linear-gradient(to bottom, #4CAF50, #2e7d32)';  // green
      } else if (!isRoundRest) {
        // SHORT REST = rising = fill from BOTTOM to TOP
        const restTime = parseInt(document.getElementById('rest').value);
        const progress = (restTime - totalSeconds) / restTime;
        calfBar.style.transform = `scaleY(${progress})`;
        calfBar.style.transformOrigin = 'bottom';
        calfBar.style.background = 'linear-gradient(to top, #ff9800, #e65100)';     // orange
      } else {
        // During long round rest → hide or keep orange (your choice)
        calfBarContainer.style.display = 'none';
      }
    }

    const muteBtn = document.getElementById('muteBtn');
    const iconSoundOn = document.getElementById('icon-sound-on');
    const iconSoundOff = document.getElementById('icon-sound-off');
    
    let audioCtx;
    let SOUND_VOLUME = 0.15; // Master volume control (0.0 to 1.0)
    
    // Volume levels in cycle order: 0.15 → 0.3 → 0.5 → 1.0 → 0 (muted) → 0.15
    const VOLUME_LEVELS = [0.15, 0.3, 0.5, 1.0, 0];
    
    // Load saved volume from localStorage, default to 0.15
    const savedVolume = localStorage.getItem('soundVolume');
    if (savedVolume !== null) {
      SOUND_VOLUME = parseFloat(savedVolume);
    }
    
    // Helper function to get next volume in cycle
    function getNextVolume(currentVolume) {
      const currentIndex = VOLUME_LEVELS.indexOf(currentVolume);
      if (currentIndex === -1) {
        // If current volume not in list, default to 0.15
        return 0.15;
      }
      const nextIndex = (currentIndex + 1) % VOLUME_LEVELS.length;
      return VOLUME_LEVELS[nextIndex];
    }
    
    // Helper function to format volume for display
    function formatVolume(volume) {
      if (volume === 0) return 'Muted';
      return `${Math.round(volume * 100)}%`;
    }

    muteBtn.addEventListener('click', () => {
      SOUND_VOLUME = getNextVolume(SOUND_VOLUME);
      updateVolumeDisplay();
      // Store the volume in localStorage
      localStorage.setItem('soundVolume', SOUND_VOLUME);
    });

    // Helper function to play a single tone
    function playTone(frequency, duration, type = 'sine') {
      if (SOUND_VOLUME === 0) return;

      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }

      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      oscillator.type = type;
      oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);

      // Fade out to avoid clicking
      gainNode.gain.setValueAtTime(SOUND_VOLUME, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);

      oscillator.start();
      oscillator.stop(audioCtx.currentTime + duration);
    }

    // 1. Rep Start Sound - High, sharp, motivational "go!" sound
    function playRepStartSound() {
      if (SOUND_VOLUME === 0) return;
      playTone(1000, 0.08); // High pitch, short beep
    }

    // 2. Rep End Sound - Lower pitch acknowledgment
    function playRepEndSound() {
      if (SOUND_VOLUME === 0) return;
      playTone(600, 0.1); // Lower pitch, slightly longer
    }

    // 3. Round Rest Start Sound - Distinctive double beep
    function playRoundRestStartSound() {
      if (SOUND_VOLUME === 0) return;
      playTone(700, 0.12); // First beep
      setTimeout(() => {
        playTone(700, 0.12); // Second beep after short delay
      }, 150);
    }

    // 4. Workout End Sound - Celebratory ascending sequence
    function playWorkoutEndSound() {
      if (SOUND_VOLUME === 0) return;
      const frequencies = [523, 659, 784, 1047]; // C5, E5, G5, C6 (C major chord)
      frequencies.forEach((freq, index) => {
        setTimeout(() => {
          playTone(freq, 0.2);
        }, index * 150);
      });
    }

    // 5. Last Rep Ding Sound - Progressively lowers pitch: G -> F -> C (ending/winding down)
    // currentSecond: 3 (G) -> 2 (F) -> 1 (C)
    function playDingSound(currentSecond) {
      if (SOUND_VOLUME === 0) return;
      let frequency;
      if (currentSecond === 3) {
        frequency = 392.00; // G4 at 3 seconds
      } else if (currentSecond === 2) {
        frequency = 349.23; // F4 at 2 seconds
      } else {
        frequency = 261.63; // C4 at 1 second
      }
      playTone(frequency, 0.18);
    }

    // 6. Round Rest Get Ready Sound - Progressively raises pitch: C -> F -> G (preparation/alert)
    // currentSecond: 3 (C) -> 2 (F) -> 1 (G)
    function playGetReadySound(currentSecond) {
      if (SOUND_VOLUME === 0) return;
      let frequency;
      if (currentSecond === 3) {
        frequency = 261.63; // C4 at 3 seconds
      } else if (currentSecond === 2) {
        frequency = 349.23; // F4 at 2 seconds
      } else {
        frequency = 392.00; // G4 at 1 second
      }
      playTone(frequency, 0.12);
    }

    // Legacy function for backward compatibility (used for phase transitions)
    function playBeep(times = 1, delay = 200) {
      if (SOUND_VOLUME === 0) return;

      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }

      if (times > 0) {
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); // A5

        // Fade out to avoid clicking
        gainNode.gain.setValueAtTime(SOUND_VOLUME, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.1);

        oscillator.start();
        oscillator.stop(audioCtx.currentTime + 0.1);

        setTimeout(() => playBeep(times - 1, delay), delay);
      }
    }

    function updateDisplay() {
      timerDisplay.textContent = formatTime(totalSeconds);
    }

    function updateProgress() {
      const rounds = parseInt(document.getElementById('rounds').value);
      const repsPerRound = parseInt(document.getElementById('reps').value);
      const workSec = parseInt(document.getElementById('work').value);
      const restSec = parseInt(document.getElementById('rest').value);
      const roundRestSec = parseInt(document.getElementById('roundRest').value);

      const totalReps = rounds * repsPerRound;

      // Completed reps (same logic as before — this part was actually fine)
      let completedReps = (currentRound - 1) * repsPerRound;
      if (isRoundRest) {
        completedReps += repsPerRound;
      } else {
        completedReps += isWorking ? (currentRep - 1) : currentRep;
      }

      // ───── CALCULATE ACTUAL REMAINING TIME ─────
      // Instead of using elapsed time (which can drift), calculate based on actual remaining phases
      const remaining = calculateRemainingTime(
        currentRound,
        currentRep,
        isWorking,
        isRoundRest,
        rounds,
        repsPerRound,
        workSec,
        restSec,
        roundRestSec,
        totalSeconds
      );

      const remainingRounded = Math.ceil(remaining);
      const mins = Math.floor(remainingRounded / 60);
      const secs = (remainingRounded % 60).toString().padStart(2, '0');
      const timeLeft = remainingRounded >= 60 ? `${mins}m ${secs}s left` : `${remainingRounded}s left`;
      const workoutProgressPct = totalWorkoutSeconds > 0 ? Math.floor(((totalWorkoutSeconds - remaining) / totalWorkoutSeconds) * 100) : 0;

      // Update Scoreboard Grid
      updateScoreboardGrid();

      progressDisplay.innerHTML = `
    Total Reps: <strong>${completedReps}</strong>/${totalReps} &nbsp;•&nbsp; 
    Time Left: <span style="color:#4CAF50;">${timeLeft}</span>
  `;

      // Update the total bar to fill from left to right
      const totalBar = document.getElementById('totalBar');
      totalBar.style.transform = `scaleX(${workoutProgressPct / 100})`;
      totalBar.style.transformOrigin = 'left';
      totalBar.style.background = 'linear-gradient(to right, #4CAF50, #2e7d32)';

    }

    function tick() {
      totalSeconds -= tickTime / 1000;
      updateDisplay();      // big 00:00 timer
      updateProgress();     // ← THIS LINE IS THE KEY (updates total remaining time every second)
      updateVisualBars();

      // BACKGROUND COLOR LOGIC
      // BACKGROUND COLOR LOGIC
      document.body.style.background =
        isWorking ? '#222' :
          isRoundRest ? '#e65100' : '#ff9800';   // dark orange for round rest, bright for rep rest

      const baseColor = isWorking ? '#fff' : '#000';
      document.body.style.color = baseColor;

      // TIMER TEXT COLOR LOGIC
      if (totalSeconds <= 3 && totalSeconds > 0) {
        if (!isWorking && !isRoundRest) {
          timerDisplay.style.color = '#4CAF50'; // Green for rest between reps
        } else {
          timerDisplay.style.color = '#ff0000'; // Red for work and round rest
        }
      } else {
        timerDisplay.style.color = ''; // Inherit from body
      }

      // LAST REP DING LOGIC - Play ding once per second during last 3 seconds of last rep in round
      // Pitch progressively lowers: 3s (high) -> 2s (medium) -> 1s (low)
      const repsPerRound = parseInt(document.getElementById('reps').value);
      if (currentRep === repsPerRound && isWorking && totalSeconds <= 3 && totalSeconds > 0) {
        const currentSecond = Math.ceil(totalSeconds);
        if (currentSecond !== lastDingSecond) {
          playDingSound(currentSecond);
          lastDingSecond = currentSecond;
        }
      }

      // ROUND REST GET READY LOGIC - Play get ready sound once per second during last 3 seconds of rest between rounds
      // Pitch progressively raises: 3s (low) -> 2s (medium) -> 1s (high)
      if (isRoundRest && totalSeconds <= 3 && totalSeconds > 0) {
        const currentSecond = Math.ceil(totalSeconds);
        if (currentSecond !== lastRoundRestDingSecond) {
          playGetReadySound(currentSecond);
          lastRoundRestDingSecond = currentSecond;
        }
      }

      if (totalSeconds <= 0) {
        nextPhase();
      }
    }

    function nextPhase() {
      const workSec = parseInt(document.getElementById('work').value);
      const restSec = parseInt(document.getElementById('rest').value);
      const roundRestSec = parseInt(document.getElementById('roundRest').value);
      const totalRounds = parseInt(document.getElementById('rounds').value);
      const repsPerRound = parseInt(document.getElementById('reps').value);

      if (isRoundRest) {
        // End of round rest → next round
        isRoundRest = false;
        currentRound++;
        currentRep = 1;
        if (currentRound > totalRounds) {
          finishWorkout();
          return;
        }
        isWorking = true;
        totalSeconds = workSec;
        playRepStartSound(); // Rep start sound
      } else if (isWorking) {
        // End of work → ALWAYS rest (between reps)
        isWorking = false;
        totalSeconds = restSec;
        playRepEndSound(); // Rep end sound
      } else {
        // End of rest (between reps)
        // Check if we finished all reps in this round
        currentRep++;
        if (currentRep > repsPerRound) {
          // Finished all reps for this round
          if (currentRound === totalRounds) {
            finishWorkout();
            return;
          }
          isRoundRest = true;
          totalSeconds = roundRestSec;
          playRoundRestStartSound(); // Round rest start sound
        } else {
          // Next rep
          isWorking = true;
          totalSeconds = workSec;
          playRepStartSound(); // Rep start sound
        }
      }

      updateProgress();
      updateDisplay();
      updateVisualBars();

      // Reset ding tracking when phase changes
      lastDingSecond = null;
      lastRoundRestDingSecond = null;

      // Force correct background immediately when phase changes
      document.body.style.background =
        isWorking ? '#222' :
          isRoundRest ? '#e65100' : '#ff9800';   // dark orange for round rest, bright for rep rest

      document.body.style.color = isWorking ? '#fff' : '#000';
      timerDisplay.style.color = '';
    }

    function startTimer() {
      if (!workoutStartedAt) {
        workoutStartedAt = Date.now();   // ← first time we press START
        // Get values from inputs
        const rounds = parseInt(document.getElementById('rounds').value);
        const repsPerRound = parseInt(document.getElementById('reps').value);
        const workSec = parseInt(document.getElementById('work').value);
        const restSec = parseInt(document.getElementById('rest').value);
        const roundRestSec = parseInt(document.getElementById('roundRest').value);
        // Calculate total workout duration
        // Calculate total workout duration
        totalWorkoutSeconds = calculateTotalWorkoutTime(rounds, repsPerRound, workSec, restSec, roundRestSec);

        toggleView(true); // Switch to running view
      }

      if (isRunning && !isPaused) return;

      isRunning = true;
      isPaused = false;
      updateMainButtonState();


      const workSec = parseInt(document.getElementById('work').value);
      if (totalSeconds === 0) {
        totalSeconds = isRoundRest ? parseInt(document.getElementById('roundRest').value) :
          (isWorking ? workSec : parseInt(document.getElementById('rest').value));
        if (totalSeconds === 0) totalSeconds = workSec;
        updateProgress();
        // Play rep start sound when workout first begins (if starting with work phase)
        if (isWorking && !isRoundRest) {
          playRepStartSound();
        }
      }

      updateDisplay();
      countdown = setInterval(tick, tickTime);
      requestWakeLock();           // ← keep screen on when workout starts
    }

    function pauseTimer() {
      isPaused = true;
      updateMainButtonState();

      lastPauseStart = Date.now();
      releaseWakeLock();
    }

    function resumeTimer() {
      if (lastPauseStart) {
        pausedTimeTotal += Date.now() - lastPauseStart;
        lastPauseStart = null;
      }

      isPaused = false;
      updateMainButtonState();

      countdown = setInterval(tick, tickTime);
      requestWakeLock();           // ← keep screen on when workout resumes
    }



    function resetTimer() {
      totalSeconds = 0;
      currentRound = 1;
      currentRep = 1;
      isWorking = true;
      isRoundRest = false;
      isRunning = false;
      isPaused = false;

      updateMainButtonState();

      updateDisplay();
      progressDisplay.textContent = '';
      document.body.style.background = '#222';
      document.body.style.color = '#fff';
      timerDisplay.style.color = '';

      workoutStartedAt = null;
      pausedTimeTotal = 0;
      lastPauseStart = null;
      lastDingSecond = null;
      lastRoundRestDingSecond = null;
      calfBarContainer.style.display = 'none';
      if (calfBar) calfBar.style.removeProperty('display'); // Ensure inner bar is visible if it was hidden
      initScoreboard(); // Re-initialize scoreboard on reset

      toggleView(false); // Switch back to setup view
      releaseWakeLock();           // ← make sure it's released on reset too
    }

    function finishWorkout() {
      console.log('finishWorkout');
      isRunning = false;
      isPaused = false;
      releaseWakeLock();           // ← definitely release when workout ends

      timerDisplay.textContent = "DONE!";
      progressDisplay.textContent = '';
      updateMainButtonState();
      resetTimer();

      playWorkoutEndSound(); // Workout end sound
      document.body.style.background = '#1b5e20';
    }

    function prevRep() {
      if (!isRunning && !isPaused) return; // Only active during workout

      const workSec = parseInt(document.getElementById('work').value);
      const restSec = parseInt(document.getElementById('rest').value);
      const roundRestSec = parseInt(document.getElementById('roundRest').value);
      const repsPerRound = parseInt(document.getElementById('reps').value);

      // Calculate elapsed time in current rep
      let elapsedInRep = 0;
      if (isRoundRest) {
        // In round rest, we consider ourselves "past" the last rep.
        // So any press should probably go back to the last rep.
        // Let's treat elapsed as > 1s effectively to trigger "restart current" logic 
        // which for round rest we might want to define as "restart round rest" or "go back to last rep"?
        // User said: "revert the workout to beginning of the previous rep"
        // If in Round Rest, "previous rep" is the last rep of the completed round.
        elapsedInRep = 0; // Logic below will handle the jump
      } else {
        if (isWorking) {
          elapsedInRep = workSec - totalSeconds;
        } else {
          elapsedInRep = workSec + (restSec - totalSeconds);
        }
      }

      // Logic:
      // a) if elapsed < 1s: revert to beginning of PREVIOUS rep
      // b) if elapsed >= 1s: revert to beginning of CURRENT rep

      // Special handling for Round Rest:
      // If in Round Rest, we are technically "between" rounds.
      // Let's assume we always want to go back to the last rep of the previous round.
      if (isRoundRest) {
        isRoundRest = false;
        // currentRound is already the round that just finished? 
        // No, wait. In nextPhase(), we increment currentRound AFTER round rest.
        // So during Round Rest, currentRound is the round that just finished.
        // Wait, let's check nextPhase again.
        // } else if (isWorking) { ... } else { ... if (currentRep > repsPerRound) { isRoundRest = true; ... } }
        // So during Round Rest, currentRound is the round that just finished.
        // So we want to go to the last rep of THIS currentRound.
        currentRep = repsPerRound;
        isWorking = true;
        totalSeconds = workSec;
      } else {
        if (elapsedInRep < 1.0) {
          // Go to PREVIOUS rep
          if (currentRep > 1) {
            currentRep--;
            isWorking = true;
            totalSeconds = workSec;
          } else {
            // First rep of the round
            if (currentRound > 1) {
              currentRound--;
              currentRep = repsPerRound;
              isWorking = true;
              totalSeconds = workSec;
            } else {
              // First rep of first round -> Just restart it
              isWorking = true;
              totalSeconds = workSec;
            }
          }
        } else {
          // Go to START of CURRENT rep
          isWorking = true;
          totalSeconds = workSec;
        }
      }

      updateDisplay();
      updateProgress();
      updateVisualBars();
      // Ensure background updates
      document.body.style.background = '#222';
      document.body.style.color = '#fff';
      timerDisplay.style.color = '';
    }

    function nextRep() {
      if (!isRunning && !isPaused) return;

      const workSec = parseInt(document.getElementById('work').value);
      const repsPerRound = parseInt(document.getElementById('reps').value);
      const totalRounds = parseInt(document.getElementById('rounds').value);

      // Always skip to beginning of NEXT rep

      if (isRoundRest) {
        // Skip round rest -> Start Rep 1 of Next Round
        isRoundRest = false;
        currentRound++;
        currentRep = 1;
        if (currentRound > totalRounds) {
          finishWorkout();
          return;
        }
        isWorking = true;
        totalSeconds = workSec;
      } else {
        // Currently in a rep (Work or Rest)
        currentRep++;
        if (currentRep > repsPerRound) {
          // Finished round -> Skip Round Rest -> Start Rep 1 of Next Round
          currentRound++;
          currentRep = 1;
          if (currentRound > totalRounds) {
            finishWorkout();
            return;
          }
          isWorking = true;
          totalSeconds = workSec;
        } else {
          // Next rep in same round
          isWorking = true;
          totalSeconds = workSec;
        }
      }

      updateDisplay();
      updateProgress();
      updateVisualBars();
      document.body.style.background = '#222';
      document.body.style.color = '#fff';
      timerDisplay.style.color = '';
    }

    prevBtn.addEventListener('click', prevRep);
    nextBtn.addEventListener('click', nextRep);



    function updateMainButtonState() {
      const iconPlay = document.getElementById('icon-play');
      const iconPause = document.getElementById('icon-pause');

      if (isRunning && !isPaused) {
        // Show Pause
        iconPlay.classList.add('hidden');
        iconPause.classList.remove('hidden');
        mainBtn.style.backgroundColor = '#f44336'; // Red for pause
      } else {
        // Show Play (Start or Resume)
        iconPlay.classList.remove('hidden');
        iconPause.classList.add('hidden');
        mainBtn.style.backgroundColor = '#4CAF50'; // Green for play
      }
    }

    // Main button logic
    mainBtn.addEventListener('click', () => {
      if (!isRunning) {
        startTimer();
      } else if (isPaused) {
        resumeTimer();
      } else {
        pauseTimer();
      }
    });


    document.getElementById('resetBtn').addEventListener('click', resetTimer);

    // Press Enter to start/resume
    document.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        // If not running, or running and paused -> click main button (which is Play/Resume)
        if (!isRunning || isPaused) {
          mainBtn.click();
        }
      }
    });

    // Spacebar or Enter to control Start / Pause / Resume
    document.addEventListener('keydown', (e) => {
      // Spacebar or Enter → toggle Start / Pause / Resume
      if (e.key === ' ' || e.key === 'Enter') {
        e.preventDefault(); // prevents page scroll when pressing space

        // If we're on the "START" or "RESUME" state → click it
        if (!isRunning || isPaused) {
          mainBtn.click();
        }
        // If we're running and not already paused → pause
        else if (isRunning && !isPaused) {
          mainBtn.click(); // triggers pause
        }
      }
    });

    // ──────────────────────────────
    // Prevent screen sleep / dimming / lock while timer is running
    // Works on Chrome, Edge, Safari (iOS/macOS), Firefox (with permissions)
    // ──────────────────────────────
    let wakeLock = null;

    async function requestWakeLock() {
      if ('wakeLock' in navigator) {
        try {
          wakeLock = await navigator.wakeLock.request('screen');
          console.log('Screen wake lock active – screen will stay on');

          // Re-request if the system tries to turn it off (some browsers release it on visibility change)
          wakeLock.addEventListener('release', () => {
            console.log('Wake lock released');
          });
        } catch (err) {
          console.warn('Wake lock failed:', err);
        }
      }
    }

    function releaseWakeLock() {
      if (wakeLock) {
        wakeLock.release();
        wakeLock = null;
      }
    }

    // Re-request wake lock when page becomes visible again (e.g., after switching tabs/apps)
    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState === 'visible') {
        // If workout is running and not paused, re-request wake lock
        if (isRunning && !isPaused) {
          await requestWakeLock();
        }
      }
    });

    // Auto-update total workout time whenever ANY setting changes
    document.querySelectorAll('input').forEach(input => {
      input.addEventListener('input', updateTotalWorkoutTime);
    });

    // Also update when page first loads
    // Also update when page first loads
    // updateTotalWorkoutTime(); // REMOVED: Called in initApp via loadWorkout

    function updateTotalWorkoutTime() {
      const rounds = parseInt(document.getElementById('rounds').value) || 0;
      const repsPerRound = parseInt(document.getElementById('reps').value) || 0;
      const workSec = parseInt(document.getElementById('work').value) || 0;
      const restSec = parseInt(document.getElementById('rest').value) || 0;
      const roundRestSec = parseInt(document.getElementById('roundRest').value) || 0;

      if (rounds === 0 || repsPerRound === 0) {
        document.getElementById('totalTimeDisplay').textContent = '—';
        return;
      }

      const totalTime = calculateTotalWorkoutTime(rounds, repsPerRound, workSec, restSec, roundRestSec);

      const mins = Math.floor(totalTime / 60);
      const secs = (totalTime % 60).toString().padStart(2, '0');
      document.getElementById('totalTimeDisplay').textContent =
        totalTime >= 3600 ? `${Math.floor(totalTime / 3600)}h ${mins}m ${secs}s` :
          mins > 0 ? `${mins}m ${secs}s` : `${totalTime}s`;
    }

    // Call it on page load and whenever any input changes
    // Call it on page load and whenever any input changes
    // window.addEventListener('load', updateTotalWorkoutTime); // REMOVED: Handled in initApp
    document.querySelectorAll('#rounds, #reps, #work, #rest, #roundRest').forEach(input => {
      input.addEventListener('input', updateTotalWorkoutTime);
    });

    // ──────────────────────────────
    // DYNAMIC SCOREBOARD LOGIC
    // ──────────────────────────────
    function initScoreboard() {
      const rounds = parseInt(document.getElementById('rounds').value) || 6;
      const reps = parseInt(document.getElementById('reps').value) || 15;
      const grid = document.getElementById('sbGrid');

      let html = '';

      // Headers
      html += `<div class="sb-cell sb-header sb-header-round">Round</div>`;
      html += `<div class="sb-cell sb-header sb-header-planned"><span class="desktop-text">Plan</span><span class="mobile-text">Plan</span></div>`;
      html += `<div class="sb-cell sb-header sb-header-completed"><span class="desktop-text">Done</span><span class="mobile-text">Done</span></div>`;

      // Rounds
      for (let i = 1; i <= rounds; i++) {
        // Round Label (Mobile only) - Just the number
        html += `<div class="sb-cell sb-round-label">${i}</div>`;
        // Planned Value
        html += `<div id="sb-plan-${i}" class="sb-cell sb-val-planned">${reps}</div>`;
        // Completed Value
        html += `<div id="sb-comp-${i}" class="sb-cell sb-val-completed">0</div>`;
      }

      grid.innerHTML = html;
      updateScoreboardGrid();
    }

    function updateScoreboardGrid() {
      const rounds = parseInt(document.getElementById('rounds').value) || 6;
      const repsPerRound = parseInt(document.getElementById('reps').value) || 15;

      for (let i = 1; i <= rounds; i++) {
        const cellPlan = document.getElementById(`sb-plan-${i}`);
        const cellComp = document.getElementById(`sb-comp-${i}`);
        if (!cellPlan || !cellComp) continue;

        // Reset classes (keep base classes)
        cellPlan.className = 'sb-cell sb-val-planned';
        cellComp.className = 'sb-cell sb-val-completed';

        if (i < currentRound) {
          // Past rounds
          cellComp.textContent = repsPerRound;
          cellPlan.classList.add('col-past');
          cellComp.classList.add('col-past');
        } else if (i === currentRound) {
          // Current round
          let completedInRound = isRoundRest ? repsPerRound : currentRep - (isRunning ? 0 : 1);
          cellComp.textContent = completedInRound;
          cellPlan.classList.add('col-active');
          cellComp.classList.add('col-active');
        } else {
          // Future rounds
          cellComp.textContent = '0';
          cellPlan.classList.add('col-future');
          cellComp.classList.add('col-future');
        }
      }
    }

    // Re-init scoreboard when settings change
    document.querySelectorAll('#rounds, #reps').forEach(input => {
      input.addEventListener('change', initScoreboard);
    });

    // Initialize input values from DEFAULT_CONFIG
    function initInputValues() {
      document.getElementById('rounds').value = DEFAULT_CONFIG.rounds;
      document.getElementById('reps').value = DEFAULT_CONFIG.reps;
      document.getElementById('work').value = DEFAULT_CONFIG.work;
      document.getElementById('rest').value = DEFAULT_CONFIG.rest;
      document.getElementById('roundRest').value = DEFAULT_CONFIG.roundRest;
    }

    // Load a predefined workout
    function loadWorkout(workout) {
      currentWorkout = workout;
      document.getElementById('workoutTitle').textContent = workout.name + ' ' + workout.config.rounds + ' x ' + workout.config.reps;
      document.getElementById('rounds').value = workout.config.rounds;
      document.getElementById('reps').value = workout.config.reps;
      document.getElementById('work').value = workout.config.work;
      document.getElementById('rest').value = workout.config.rest;
      document.getElementById('roundRest').value = workout.config.roundRest;
      updateTotalWorkoutTime();
      resetTimer();
    }

    // Initialize workout modal
    function initWorkoutModal() {
      const workoutList = document.getElementById('workoutList');
      const modal = document.getElementById('workoutModal');
      const trigger = document.getElementById('workoutMenuTrigger');
      const closeBtn = document.getElementById('modalClose');

      // Populate workout list
      workoutList.innerHTML = PREDEFINED_WORKOUTS.map(workout =>
        `<button class="workout-option" data-workout-id="${workout.id}">${workout.name} ${workout.config.rounds} x ${workout.config.reps}</button>`
      ).join('');

      // Open modal
      trigger.addEventListener('click', (e) => {
        e.preventDefault();
        modal.classList.add('show');
      });

      // Close modal
      closeBtn.addEventListener('click', () => {
        modal.classList.remove('show');
      });

      // Close on outside click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.classList.remove('show');
        }
      });

      // Load workout on selection
      workoutList.addEventListener('click', (e) => {
        if (e.target.classList.contains('workout-option')) {
          const workoutId = e.target.dataset.workoutId;
          const workout = PREDEFINED_WORKOUTS.find(w => w.id === workoutId);
          if (workout) {
            loadWorkout(workout);
            modal.classList.remove('show');
          }
        }
      });
    }

    function updateVolumeDisplay() {
      // Get volume bar elements
      const bar1 = document.getElementById('volume-bar-1');
      const bar2 = document.getElementById('volume-bar-2');
      const bar3 = document.getElementById('volume-bar-3');
      const bar4 = document.getElementById('volume-bar-4');
      
      // Reset all bars
      [bar1, bar2, bar3, bar4].forEach(bar => {
        bar.classList.remove('active', 'bar-1', 'bar-2', 'bar-3', 'bar-4');
      });
      
      if (SOUND_VOLUME === 0) {
        // Muted: show sound-off icon, hide all bars
        iconSoundOn.classList.add('hidden');
        iconSoundOff.classList.remove('hidden');
        muteBtn.title = 'Sound: Muted (click to cycle volume)';
      } else {
        // Not muted: show sound-on icon and volume bars
        iconSoundOn.classList.remove('hidden');
        iconSoundOff.classList.add('hidden');
        muteBtn.title = `Sound: ${formatVolume(SOUND_VOLUME)} (click to cycle volume)`;
        
        // Show volume bars based on volume level
        if (SOUND_VOLUME >= 0.15) {
          bar1.classList.add('active', 'bar-1');
        }
        if (SOUND_VOLUME >= 0.3) {
          bar2.classList.add('active', 'bar-2');
        }
        if (SOUND_VOLUME >= 0.5) {
          bar3.classList.add('active', 'bar-3');
        }
        if (SOUND_VOLUME >= 1.0) {
          bar4.classList.add('active', 'bar-4');
        }
      }
    }
    
    // Legacy function name for compatibility (if used elsewhere)
    function showIsMutedButton(isMuted) {
      // This is now handled by updateVolumeDisplay, but keeping for compatibility
      updateVolumeDisplay();
    }

    // Init on load
    // Init on load
    // Init App
    function initApp() {
      initInputValues();
      initScoreboard();
      initWorkoutModal();
      loadWorkout(currentWorkout); // Load default workout (Alfredson)
      updateVolumeDisplay(); // Initialize volume display
    }

    // Run initialization when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initApp);
    } else {
      initApp();
    }


  </script>
</body>

</html>